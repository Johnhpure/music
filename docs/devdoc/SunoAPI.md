# Suno API 文档

> 完整的 Suno API 文档 - 您获取经济实惠且稳定的 AI 音乐 API 服务的门户

# 欢迎使用 Suno API 文档

本文档为集成 [Suno API](https://sunoapi.org/) 提供全面的指南和参考，Suno API 是一个提供经济实惠且稳定的 AI 音乐 API 服务平台，可无缝集成到您的项目中。

## 关于 Suno API

Suno API 通过易于集成的API提供先进的AI音乐功能，包括音乐生成、歌词创作、音频处理和视频制作。我们的平台专为需要以下功能的开发者和企业而设计：

* **99.9% 正常运行时间** - 可靠稳定的API性能
* **经济实惠的定价** - 透明的按使用量计费系统
* **20秒流式输出** - 快速响应的流式传输
* **高并发处理** - 随需求增长的可扩展解决方案
* **24/7 支持** - 专业技术援助
* **无水印** - 可商用的音乐生成

## 快速开始指南

通过我们全面的API快速开始指南快速上手：

### 🎵 音乐生成 APIs

<Card title="音乐生成" icon="music" href="/cn/suno-api/generate-music">
  使用先进的AI模型从文本描述创建高质量音乐，支持各种风格和流派。
</Card>

<Card title="音乐扩展" icon="forward" href="/cn/suno-api/extend-music">
  使用AI驱动的续写扩展现有音乐轨道，保持音乐的连贯性和风格。
</Card>

<Card title="上传翻唱音频" icon="upload" href="/cn/suno-api/upload-and-cover-audio">
  使用AI音乐处理技术将现有音频转换为新的风格和编排。
</Card>

<Card title="上传扩展音频" icon="plus" href="/cn/suno-api/upload-and-extend-audio">
  上传您自己的音频文件并用AI生成的内容进行扩展。
</Card>

<Card title="添加人声" icon="microphone" href="/cn/suno-api/add-vocals">
  使用先进的AI模型为器乐音乐生成人声轨道。
</Card>

<Card title="添加伴奏" icon="music" href="/cn/suno-api/add-instrumental">
  使用AI驱动的编排为人声轨道创建器乐伴奏。
</Card>

<Card title="翻唱音乐" icon="repeat" href="/cn/suno-api/cover-suno">
  使用AI技术将现有音乐重新演绎为不同的风格和编排。
</Card>

### ✍️ 歌词创作 APIs

<Card title="歌词生成" icon="pen-to-square" href="/cn/suno-api/generate-lyrics">
  为您的歌曲创建AI驱动的歌词，支持自定义主题和风格。
</Card>

<Card title="时间戳歌词" icon="clock" href="/cn/suno-api/get-timestamped-lyrics">
  获取带有精确时间戳的歌词，用于与音轨同步。
</Card>

### 🔊 音频处理 APIs

<Card title="人声音乐分离" icon="waveform-lines" href="/cn/suno-api/separate-vocals-from-music">
  使用先进的AI音频分离技术单独提取人声和伴奏轨道。
</Card>

<Card title="WAV格式转换" icon="file-audio" href="/cn/suno-api/convert-to-wav-format">
  将生成的音乐转换为高质量WAV格式，适合专业使用。
</Card>

<Card title="音乐风格增强" icon="sparkles" href="/cn/suno-api/boost-music-style">
  使用AI驱动的音频处理增强和完善音乐风格。
</Card>

### 🎬 音乐视频 APIs

<Card title="音乐视频制作" icon="video" href="/cn/suno-api/create-music-video">
  使用AI视频生成技术从音轨创建可视化音乐视频。
</Card>

### 🛠️ 工具 APIs

<Card title="音乐生成详情" icon="magnifying-glass" href="/cn/suno-api/get-music-generation-details">
  监控并获取音乐生成任务的详细信息。
</Card>

<Card title="剩余积分查询" icon="coins" href="/cn/suno-api/get-remaining-credits">
  检查您的账户积分余额和使用统计。
</Card>

<Card title="歌词生成详情" icon="list-check" href="/cn/suno-api/get-lyrics-generation-details">
  跟踪歌词生成请求的状态和详细信息。
</Card>

<Card title="WAV转换详情" icon="file-audio" href="/cn/suno-api/get-wav-conversion-details">
  监控WAV格式转换任务和下载状态。
</Card>

<Card title="人声分离详情" icon="waveform-lines" href="/cn/suno-api/get-vocal-separation-details">
  检查人声分离任务的进度并访问分离的音频文件。
</Card>

<Card title="音乐视频详情" icon="video" href="/cn/suno-api/get-music-video-details">
  跟踪音乐视频生成进度并检索下载链接。
</Card>

<Card title="翻唱详情" icon="info" href="/cn/suno-api/get-cover-suno-details">
  监控音乐翻唱任务的状态并获取翻唱结果。
</Card>

## 文档特性

* **交互式示例** - 直接在我们的文档中测试 API
* **代码示例** - 多种编程语言的即用示例
* **全面指南** - 逐步集成说明
* **API 参考** - 完整的参数文档和响应模式
* **最佳实践** - 优化技巧和常见用例
* **回调文档** - 所有端点的 Webhook 集成指南

## 核心特性

### 🚀 最新AI音乐模型

我们提供最新AI音乐模型的API，包括Suno V5、V4.5 Plus、V4.5、V4和V3.5，提供高质量的音乐生成。支持创建人声和器乐轨道、音乐扩展和多格式下载。

### 💎 无水印商业使用

通过我们的API生成的所有音乐都是无水印的，可以立即用于商业项目。这消除了额外费用的需要，使创作者和开发者能够轻松地将高质量轨道集成到他们的工作流程中。

### ⚡ 20秒流式输出

我们通过流式输出确保快速交付，使开发者能够无延迟地将AI生成的音乐无缝集成到他们的工作流程中。此功能支持实时应用和直播内容创作。

### 🏗️ 高并发架构

我们的API旨在处理多个同时请求，即使在高流量下也能确保可靠的性能。这使其成为大规模应用和高需求平台的理想选择。

### 💰 透明且经济实惠的定价

我们提供经济高效且透明的定价计划，使创作者和企业都能负担得起。我们透明的按使用量计费模式确保可预测的成本。

### 🔧 全面的开发者支持

我们通过详细的、对开发者友好的API文档简化集成，确保无忧的实施过程。由经验丰富的技术团队支持。

## 开始使用

1. **注册** - 在[Suno API](https://sunoapi.org/)创建您的免费账户
2. **获取API密钥** - 从[API密钥管理页面](https://sunoapi.org/api-key)获取您的身份验证凭据
3. **选择您的API** - 从我们全面的API集合中选择
4. **遵循快速开始** - 使用我们的[快速开始指南](/cn/suno-api/quickstart)进行快速集成
5. **测试和部署** - 验证您的集成并上线

## AI模型版本

为您的需求选择合适的模型：

### V3\_5 - 更好的歌曲结构

改进的歌曲组织，具有清晰的主歌/副歌模式，最长4分钟。非常适合结构化音乐作品。

### V4 - 改进的人声

增强的人声质量和精细的音频处理，最长4分钟。当人声清晰度最重要时的理想选择。

### V4\_5 - 智能提示词

卓越的提示词理解和更快的生成速度，最长8分钟。我们用于复杂音乐请求的先进模型。

### V4\_5PLUS - 更丰富的音色

最先进的模型，具有增强的音色变化和新的创作方法，最长8分钟。最高质量和最长轨道的最佳选择。

### V5 - 最新模型

具有增强质量和功能的尖端模型。我们用于高级音乐生成的最新产品。

## 使用案例

### 🎮 游戏开发者

使用我们的音乐生成和扩展API为游戏体验生成动态背景音乐、音效和自适应音频。

### 🎬 内容创作者

通过我们的无水印输出为视频、播客和社交媒体内容创建免版税音乐，享有无限商业使用权。

### 🏢 企业

使用我们的高并发API将AI音乐生成集成到应用、网站和服务中，增强用户体验。

### 🎭 音乐制作人

原型歌曲、生成创意并创建具有专业质量输出的完整作品。使用人声分离进行混音和音频处理。

### 🎤 卡拉OK和娱乐

利用时间戳歌词和人声分离功能进行卡拉OK应用和交互式音乐体验。

## 支持和社区

* **24/7 支持** - 随时联系我们的技术团队
* **邮件支持** - [support@sunoapi.org](mailto:support@sunoapi.org)
* **文档更新** - 定期改进和新功能
* **API状态** - 监控实时服务状态
* **开发者资源** - 全面的指南和最佳实践

## 回调集成

所有主要端点都支持实时通知的webhook回调：

* [音乐生成回调](/cn/suno-api/generate-music-callbacks)
* [歌词生成回调](/cn/suno-api/generate-lyrics-callbacks)
* [音乐扩展回调](/cn/suno-api/extend-music-callbacks)
* [音频处理回调](/cn/suno-api/separate-vocals-from-music-callbacks)
* [音乐视频回调](/cn/suno-api/create-music-video-callbacks)
* [WAV转换回调](/cn/suno-api/convert-to-wav-format-callbacks)
* [翻唱回调](/cn/suno-api/cover-suno-callbacks)
* [上传翻唱回调](/cn/suno-api/upload-and-cover-audio-callbacks)
* [上传扩展回调](/cn/suno-api/upload-and-extend-audio-callbacks)
* [添加人声回调](/cn/suno-api/add-vocals-callbacks)
* [添加伴奏回调](/cn/suno-api/add-instrumental-callbacks)

## API基础URL

所有API请求应发送到：

```
https://api.sunoapi.org
```

## 身份验证

所有API请求都需要使用Bearer令牌进行身份验证：

```http  theme={null}
Authorization: Bearer YOUR_API_KEY
```

从[API密钥管理页面](https://sunoapi.org/api-key)获取您的API密钥。

***

准备开始了吗？选择上面的API并遵循快速开始指南，开始将强大的AI音乐功能集成到您的项目中。访问[Suno API](https://sunoapi.org/)创建您的账户，今天就开始生成令人惊叹的音乐！


# Suno API 快速开始

> 几分钟内开始使用 Suno API 生成高质量的AI音乐、歌词和音频处理

## 欢迎使用 Suno API

Suno API 基于先进的AI模型，为您提供全面的音乐生成和音频处理服务。无论您需要音乐创作、歌词生成、音频编辑还是人声分离，我们的API都能满足您的所有创意需求。

<CardGroup cols={2}>
  <Card title="音乐生成" icon="music" href="/cn/suno-api/generate-music">
    从文本描述生成高质量音乐
  </Card>

  <Card title="歌词创作" icon="pen-to-square" href="/cn/suno-api/generate-lyrics">
    为您的歌曲创建AI驱动的歌词
  </Card>

  <Card title="音频处理" icon="waveform-lines" href="/cn/suno-api/separate-vocals-from-music">
    扩展、转换和分离音频轨道
  </Card>

  <Card title="音乐视频" icon="video" href="/cn/suno-api/create-music-video">
    从音频生成可视化音乐视频
  </Card>
</CardGroup>

## 身份验证

所有 API 请求都需要使用 Bearer 令牌进行身份验证。请从 [API 密钥管理页面](https://sunoapi.org/api-key) 获取您的 API 密钥。

<Warning>
  请妥善保管您的 API 密钥，切勿公开分享。如果怀疑密钥泄露，请立即重置。
</Warning>

### API 基础 URL

```
https://api.sunoapi.org
```

### 身份验证请求头

```http  theme={null}
Authorization: Bearer YOUR_API_KEY
```

## 快速开始指南

### 第一步：生成您的第一首歌曲

从一个简单的音乐生成请求开始：

<CodeGroup>
  ```bash cURL theme={null}
  curl -X POST "https://api.sunoapi.org/api/v1/generate" \
    -H "Authorization: Bearer YOUR_API_KEY" \
    -H "Content-Type: application/json" \
    -d '{
      "prompt": "一首宁静的原声吉他旋律配柔和人声，民谣风格",
      "customMode": false,
      "instrumental": false,
      "model": "V3_5",
      "callBackUrl": "https://your-server.com/callback"
    }'
  ```

  ```javascript JavaScript theme={null}
  const response = await fetch('https://api.sunoapi.org/api/v1/generate', {
    method: 'POST',
    headers: {
      'Authorization': 'Bearer YOUR_API_KEY',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      prompt: '一首宁静的原声吉他旋律配柔和人声，民谣风格',
      customMode: false,
      instrumental: false,
      model: 'V3_5',
      callBackUrl: 'https://your-server.com/callback'
    })
  });

  const data = await response.json();
  console.log('任务ID:', data.data.taskId);
  ```

  ```python Python theme={null}
  import requests

  url = "https://api.sunoapi.org/api/v1/generate"
  headers = {
      "Authorization": "Bearer YOUR_API_KEY",
      "Content-Type": "application/json"
  }

  payload = {
      "prompt": "一首宁静的原声吉他旋律配柔和人声，民谣风格",
      "customMode": False,
      "instrumental": False,
      "model": "V3_5",
      "callBackUrl": "https://your-server.com/callback"
  }

  response = requests.post(url, json=payload, headers=headers)
  result = response.json()

  print(f"任务ID: {result['data']['taskId']}")
  ```

  ```php PHP theme={null}
  <?php
  $url = 'https://api.sunoapi.org/api/v1/generate';
  $headers = [
      'Authorization: Bearer YOUR_API_KEY',
      'Content-Type: application/json'
  ];

  $payload = [
      'prompt' => '一首宁静的原声吉他旋律配柔和人声，民谣风格',
      'customMode' => false,
      'instrumental' => false,
      'model' => 'V3_5',
      'callBackUrl' => 'https://your-server.com/callback'
  ];

  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_POST, true);
  curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($payload));
  curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

  $response = curl_exec($ch);
  curl_close($ch);

  $result = json_decode($response, true);
  echo "任务ID: " . $result['data']['taskId'];
  ?>
  ```
</CodeGroup>

### 第二步：检查任务状态

使用返回的任务ID检查生成状态：

<CodeGroup>
  ```bash cURL theme={null}
  curl -X GET "https://api.sunoapi.org/api/v1/generate/record-info?taskId=YOUR_TASK_ID" \
    -H "Authorization: Bearer YOUR_API_KEY"
  ```

  ```javascript JavaScript theme={null}
  const response = await fetch(`https://api.sunoapi.org/api/v1/generate/record-info?taskId=${taskId}`, {
    headers: {
      'Authorization': 'Bearer YOUR_API_KEY'
    }
  });

  const result = await response.json();

  if (result.data.status === 'SUCCESS') {
    console.log('生成完成！');
    console.log('音频URLs:', result.data.response.data);
  } else if (result.data.status === 'GENERATING') {
    console.log('正在生成中...');
  } else {
    console.log('生成失败:', result.data.status);
  }
  ```

  ```python Python theme={null}
  import requests
  import time

  def check_task_status(task_id, api_key):
      url = f"https://api.sunoapi.org/api/v1/generate/record-info?taskId={task_id}"
      headers = {"Authorization": f"Bearer {api_key}"}
      
      response = requests.get(url, headers=headers)
      result = response.json()
      
      status = result['data']['status']
      
      if status == 'SUCCESS':
          print("生成完成！")
          audio_data = result['data']['response']['data']
          for i, audio in enumerate(audio_data):
              print(f"音轨 {i+1}: {audio['audio_url']}")
          return audio_data
      elif status == 'GENERATING':
          print("正在生成中...")
          return None
      else:
          print(f"生成失败: {status}")
          return None

  # 轮询直到完成
  task_id = "YOUR_TASK_ID"
  while True:
      audio_data = check_task_status(task_id, "YOUR_API_KEY")
      if audio_data:
          break
      time.sleep(30)  # 等待30秒后再次检查
  ```
</CodeGroup>

### 响应格式

**成功响应：**

```json  theme={null}
{
  "code": 200,
  "msg": "success",
  "data": {
    "taskId": "suno_task_abc123"
  }
}
```

**任务状态响应：**

```json  theme={null}
{
  "code": 200,
  "msg": "success",
  "data": {
    "taskId": "suno_task_abc123",
    "status": "SUCCESS",
    "response": {
      "data": [
        {
          "id": "audio_123",
          "audio_url": "https://example.com/generated-music.mp3",
          "title": "生成的歌曲",
          "tags": "民谣, 原声",
          "duration": 180.5
        }
      ]
    }
  }
}
```

## 核心功能

### 音乐生成

从文本描述创建完整歌曲：

```json  theme={null}
{
  "prompt": "一首充满活力的电子舞曲，带有合成器主音",
  "customMode": true,
  "style": "电子舞曲",
  "title": "数字梦境",
  "instrumental": false,
  "model": "V4_5"
}
```

### 歌词创作

独立生成AI驱动的歌词：

```json  theme={null}
{
  "prompt": "一首关于克服挑战和找到内在力量的歌曲",
  "callBackUrl": "https://your-server.com/lyrics-callback"
}
```

### 音频扩展

扩展现有音乐轨道：

```json  theme={null}
{
  "audioId": "e231****-****-****-****-****8cadc7dc",
  "defaultParamFlag": true,
  "prompt": "继续添加吉他独奏",
  "continueAt": 120,
  "model": "V3_5"
}
```

### 上传翻唱

用新风格转换现有音频：

```json  theme={null}
{
  "uploadUrl": "https://example.com/original-audio.mp3",
  "customMode": true,
  "style": "爵士",
  "title": "爵士版本",
  "prompt": "转换为流畅的爵士风格"
}
```

## 模型版本

为您的需求选择合适的模型：

<CardGroup cols={3}>
  <Card title="V3_5" icon="music">
    **平衡型**

    创意多样性的扎实编排，最长4分钟
  </Card>

  <Card title="V4" icon="waveform-lines">
    **高质量**

    最佳音频质量和精细的歌曲结构，最长4分钟
  </Card>

  <Card title="V4_5" icon="sparkles">
    **高级**

    卓越的流派融合和智能提示，最长8分钟
  </Card>

  <Card title="V4_5PLUS" icon="star">
    **更丰富音色**

    音色更丰富，新的创作方式，最长8分钟
  </Card>

  <Card title="V5" icon="bolt">
    **生成更快**

    更卓越的音乐表现力，速度更快，最长8分钟
  </Card>
</CardGroup>

## 关键参数

<ParamField path="prompt" type="string">
  音乐生成的文本描述。提供详细、具体的描述以获得更好的结果。

  **提示词技巧：**

  * 描述音乐风格和流派
  * 包含情绪和氛围
  * 指定乐器和人声
  * 添加节拍和能量描述
</ParamField>

<ParamField path="model" type="string" required>
  要使用的模型版本：

  * `V3_5` - 创意多样性，最长4分钟
  * `V4` - 最佳音频质量，最长4分钟
  * `V4_5` - 高级功能，最长8分钟
  * `V4_5PLUS` - 更丰富音色，最长8分钟
  * `V5` - 生成速度更快，更卓越音乐表现力，最长8分钟
</ParamField>

<ParamField path="customMode" type="boolean">
  启用自定义参数模式以进行高级控制。当为 `true` 时，需要额外的参数如 `style` 和 `title`。
</ParamField>

<ParamField path="instrumental" type="boolean">
  生成无人声的纯音乐。默认为 `false`。
</ParamField>

<ParamField path="style" type="string">
  音乐风格或流派（自定义模式下必需）。示例："爵士"、"摇滚"、"古典"、"电子"
</ParamField>

<ParamField path="title" type="string">
  歌曲标题（自定义模式下必需）。最多80个字符。
</ParamField>

<ParamField path="callBackUrl" type="string">
  接收完成通知的URL。详见回调文档。
</ParamField>

## 完整工作流程示例

以下是完整的音乐生成和处理示例：

<Tabs>
  <Tab title="JavaScript">
    ```javascript  theme={null}
    class SunoAPI {
      constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = 'https://api.sunoapi.org/api/v1';
      }
      
      async generateMusic(options) {
        const response = await fetch(`${this.baseUrl}/generate`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(options)
        });
        
        const result = await response.json();
        if (result.code !== 200) {
          throw new Error(`生成失败: ${result.msg}`);
        }
        
        return result.data.taskId;
      }
      
      async generateLyrics(prompt) {
        const response = await fetch(`${this.baseUrl}/lyrics`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            prompt,
            callBackUrl: 'https://your-server.com/lyrics-callback'
          })
        });
        
        const result = await response.json();
        return result.data.taskId;
      }
      
      async waitForCompletion(taskId, maxWaitTime = 600000) { // 最长等待10分钟
        const startTime = Date.now();
        
        while (Date.now() - startTime < maxWaitTime) {
          const status = await this.getTaskStatus(taskId);
          
          if (status.status === 'SUCCESS') {
            return status.response;
          } else if (status.status === 'FAILED') {
            throw new Error(`生成失败: ${status.errorMessage}`);
          }
          
          // 等待30秒后再次检查
          await new Promise(resolve => setTimeout(resolve, 30000));
        }
        
        throw new Error('生成超时');
      }
      
      async getTaskStatus(taskId) {
        const response = await fetch(`${this.baseUrl}/generate/record-info?taskId=${taskId}`, {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`
          }
        });
        
        const result = await response.json();
        return result.data;
      }
      
      async extendMusic(audioId, options) {
        const response = await fetch(`${this.baseUrl}/generate/extend`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            audioId,
            ...options
          })
        });
        
        const result = await response.json();
        return result.data.taskId;
      }
      
      async separateVocals(taskId, audioId) {
        const response = await fetch(`${this.baseUrl}/vocal-removal/generate`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            taskId,
            audioId,
            callBackUrl: 'https://your-server.com/vocal-callback'
          })
        });
        
        const result = await response.json();
        return result.data.taskId;
      }
      
      async getRemainingCredits() {
        const response = await fetch(`${this.baseUrl}/get-credits`, {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`
          }
        });
        
        const result = await response.json();
        return result.data.credits;
      }
    }

    // 使用示例
    async function main() {
      const api = new SunoAPI('YOUR_API_KEY');
      
      try {
        // 检查剩余积分
        const credits = await api.getRemainingCredits();
        console.log(`剩余积分: ${credits}`);
        
        // 首先生成歌词
        console.log('正在生成歌词...');
        const lyricsTaskId = await api.generateLyrics(
          '一首关于冒险和发现的歌曲，振奋人心且鼓舞人心'
        );
        
        const lyricsResult = await api.waitForCompletion(lyricsTaskId);
        console.log('歌词已生成:', lyricsResult.data[0].text);
        
        // 使用自定义参数生成音乐
        console.log('正在生成音乐...');
        const musicTaskId = await api.generateMusic({
          prompt: lyricsResult.data[0].text,
          customMode: true,
          style: '民谣流行',
          title: '冒险之歌',
          instrumental: false,
          model: 'V4_5',
          callBackUrl: 'https://your-server.com/music-callback'
        });
        
        // 等待完成
        const musicResult = await api.waitForCompletion(musicTaskId);
        console.log('音乐生成成功！');
        
        musicResult.data.forEach((track, index) => {
          console.log(`音轨 ${index + 1}:`);
          console.log(`  标题: ${track.title}`);
          console.log(`  时长: ${track.duration}秒`);
          console.log(`  音频URL: ${track.audio_url}`);
        });
        
        // 扩展第一个音轨
        const originalTrack = musicResult.data[0];
        console.log('正在扩展音乐...');
        const extendTaskId = await api.extendMusic(originalTrack.id, {
          defaultParamFlag: true,
          prompt: '继续添加美妙的器乐尾奏',
          continueAt: originalTrack.duration - 30, // 从结束前30秒开始扩展
          model: 'V4_5'
        });
        
        const extendedResult = await api.waitForCompletion(extendTaskId);
        console.log('扩展版本已创建:', extendedResult.data[0].audio_url);
        
        // 分离人声
        console.log('正在分离人声...');
        const separationTaskId = await api.separateVocals(musicTaskId, originalTrack.id);
        const separationResult = await api.waitForCompletion(separationTaskId);
        
        console.log('人声分离完成:');
        console.log(`  伴奏: ${separationResult.vocal_removal_info.instrumental_url}`);
        console.log(`  纯人声: ${separationResult.vocal_removal_info.vocal_url}`);
        
      } catch (error) {
        console.error('错误:', error.message);
      }
    }

    main();
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={null}
    import requests
    import time

    class SunoAPI:
        def __init__(self, api_key):
            self.api_key = api_key
            self.base_url = 'https://api.sunoapi.org/api/v1'
            self.headers = {
                'Authorization': f'Bearer {api_key}',
                'Content-Type': 'application/json'
            }
        
        def generate_music(self, **options):
            response = requests.post(f'{self.base_url}/generate', 
                                   headers=self.headers, json=options)
            result = response.json()
            
            if result['code'] != 200:
                raise Exception(f"生成失败: {result['msg']}")
            
            return result['data']['taskId']
        
        def generate_lyrics(self, prompt):
            response = requests.post(f'{self.base_url}/lyrics',
                                   headers=self.headers,
                                   json={
                                       'prompt': prompt,
                                       'callBackUrl': 'https://your-server.com/lyrics-callback'
                                   })
            result = response.json()
            return result['data']['taskId']
        
        def wait_for_completion(self, task_id, max_wait_time=600):
            start_time = time.time()
            
            while time.time() - start_time < max_wait_time:
                status = self.get_task_status(task_id)
                
                if status['status'] == 'SUCCESS':
                    return status['response']
                elif status['status'] == 'FAILED':
                    raise Exception(f"生成失败: {status.get('errorMessage')}")
                
                time.sleep(30)  # 等待30秒
            
            raise Exception('生成超时')
        
        def get_task_status(self, task_id):
            response = requests.get(f'{self.base_url}/generate/record-info?taskId={task_id}',
                                  headers={'Authorization': f'Bearer {self.api_key}'})
            return response.json()['data']
        
        def extend_music(self, audio_id, **options):
            response = requests.post(f'{self.base_url}/generate/extend',
                                   headers=self.headers,
                                   json={'audioId': audio_id, **options})
            return response.json()['data']['taskId']
        
        def separate_vocals(self, task_id, audio_id):
            response = requests.post(f'{self.base_url}/vocal-removal/generate',
                                   headers=self.headers,
                                   json={
                                       'taskId': task_id,
                                       'audioId': audio_id,
                                       'callBackUrl': 'https://your-server.com/vocal-callback'
                                   })
            return response.json()['data']['taskId']
        
        def get_remaining_credits(self):
            response = requests.get(f'{self.base_url}/get-credits',
                                  headers={'Authorization': f'Bearer {self.api_key}'})
            return response.json()['data']['credits']

    # 使用示例
    def main():
        api = SunoAPI('YOUR_API_KEY')
        
        try:
            # 检查剩余积分
            credits = api.get_remaining_credits()
            print(f'剩余积分: {credits}')
            
            # 首先生成歌词
            print('正在生成歌词...')
            lyrics_task_id = api.generate_lyrics(
                '一首关于冒险和发现的歌曲，振奋人心且鼓舞人心'
            )
            
            lyrics_result = api.wait_for_completion(lyrics_task_id)
            print('歌词已生成:', lyrics_result['data'][0]['text'])
            
            # 使用自定义参数生成音乐
            print('正在生成音乐...')
            music_task_id = api.generate_music(
                prompt=lyrics_result['data'][0]['text'],
                customMode=True,
                style='民谣流行',
                title='冒险之歌',
                instrumental=False,
                model='V4_5',
                callBackUrl='https://your-server.com/music-callback'
            )
            
            # 等待完成
            music_result = api.wait_for_completion(music_task_id)
            print('音乐生成成功！')
            
            for i, track in enumerate(music_result['data']):
                print(f'音轨 {i + 1}:')
                print(f'  标题: {track["title"]}')
                print(f'  时长: {track["duration"]}秒')
                print(f'  音频URL: {track["audio_url"]}')
            
            # 扩展第一个音轨
            original_track = music_result['data'][0]
            print('正在扩展音乐...')
            extend_task_id = api.extend_music(
                original_track['id'],
                defaultParamFlag=True,
                prompt='继续添加美妙的器乐尾奏',
                continueAt=original_track['duration'] - 30,
                model='V4_5'
            )
            
            extended_result = api.wait_for_completion(extend_task_id)
            print('扩展版本已创建:', extended_result['data'][0]['audio_url'])
            
            # 分离人声
            print('正在分离人声...')
            separation_task_id = api.separate_vocals(music_task_id, original_track['id'])
            separation_result = api.wait_for_completion(separation_task_id)
            
            print('人声分离完成:')
            vocal_info = separation_result['vocal_removal_info']
            print(f'  伴奏: {vocal_info["instrumental_url"]}')
            print(f'  纯人声: {vocal_info["vocal_url"]}')
            
        except Exception as error:
            print(f'错误: {error}')

    if __name__ == '__main__':
        main()
    ```
  </Tab>
</Tabs>

## 高级功能

### 上传并扩展

上传您自己的音频并用AI扩展：

```javascript  theme={null}
const extendTaskId = await api.generateMusic({
  uploadUrl: 'https://example.com/my-song.mp3',
  defaultParamFlag: true,
  prompt: '添加摇滚吉他独奏部分',
  continueAt: 60,
  model: 'V4_5'
});
```

### 音频格式转换

将音乐转换为高质量WAV格式：

```javascript  theme={null}
const wavTaskId = await api.convertToWav({
  taskId: 'original_task_id',
  audioId: 'e231****-****-****-****-****8cadc7dc',
  callBackUrl: 'https://your-server.com/wav-callback'
});
```

### 音乐视频生成

创建可视化音乐视频：

```javascript  theme={null}
const videoTaskId = await api.createMusicVideo({
  taskId: 'music_task_id',
  audioId: 'e231****-****-****-****-****8cadc7dc',
  author: '艺术家姓名',
  domainName: 'your-brand.com',
  callBackUrl: 'https://your-server.com/video-callback'
});
```

### 使用回调

设置webhook回调以获得自动通知：

```javascript  theme={null}
// 您的回调端点
app.post('/music-callback', (req, res) => {
  const { code, data } = req.body;
  
  if (code === 200) {
    console.log('音乐准备就绪:', data.data);
    data.data.forEach(track => {
      console.log(`标题: ${track.title}`);
      console.log(`音频: ${track.audio_url}`);
    });
  } else {
    console.log('生成失败:', req.body.msg);
  }
  
  res.status(200).json({ status: 'received' });
});
```

<Card title="了解更多关于回调" icon="webhook" href="/cn/suno-api/generate-music-callbacks">
  设置webhook回调以在您的音乐准备就绪时接收自动通知。
</Card>

## 任务状态说明

<ResponseField name="GENERATING" type="处理中">
  任务正在处理中
</ResponseField>

<ResponseField name="SUCCESS" type="已完成">
  任务成功完成
</ResponseField>

<ResponseField name="FAILED" type="已失败">
  任务未能完成
</ResponseField>

<ResponseField name="PENDING" type="排队中">
  任务正在排队等待处理
</ResponseField>

## 最佳实践

<AccordionGroup>
  <Accordion title="提示词优化">
    * 使用详细、具体的音乐风格和情绪描述
    * 包含乐器规格和人声要求
    * 指定节拍、能量水平和歌曲结构
    * 避免冲突或过于复杂的描述
  </Accordion>

  <Accordion title="模型选择">
    * 使用V3\_5进行创意和实验性音乐
    * 选择V4获得标准长度的最高音频质量
    * 选择V4\_5获得高级功能和更长的音轨
    * V4\_5PLUS提供更丰富的音色和新的创作方式
    * V5生成速度更快，更卓越的音乐表现力
    * 考虑您的具体用例和质量要求
  </Accordion>

  <Accordion title="性能优化">
    * 使用回调而不是频繁轮询
    * 为失败的请求实施适当的重试逻辑
    * 监控您的积分使用情况并相应规划
    * 缓存结果以避免重新生成相似内容
  </Accordion>

  <Accordion title="错误处理">
    * 为瞬时故障实施适当的重试逻辑
    * 监控任务状态并处理超时场景
    * 在发出请求前验证输入参数
    * 记录错误以便调试和监控
  </Accordion>
</AccordionGroup>

## 文件存储和访问

<Warning>
  生成的音频文件在自动删除前存储 **15天**。下载URL可能有有限的有效期。
</Warning>

* 音频文件在生成后15天内保持可访问
* 下载并保存重要文件到您自己的存储
* 如需要，在过期后使用API重新生成内容
* 考虑为关键内容实施本地备份策略

## 下一步

<CardGroup cols={2}>
  <Card title="生成音乐" icon="music" href="/cn/suno-api/generate-music">
    音乐生成的完整API参考
  </Card>

  <Card title="创建歌词" icon="pen-to-square" href="/cn/suno-api/generate-lyrics">
    AI驱动的歌词生成
  </Card>

  <Card title="音频处理" icon="waveform-lines" href="/cn/suno-api/separate-vocals-from-music">
    扩展、转换和分离音频
  </Card>

  <Card title="回调设置" icon="webhook" href="/cn/suno-api/generate-music-callbacks">
    设置自动通知
  </Card>
</CardGroup>

## 支持

<Info>
  需要帮助吗？我们的技术支持团队随时为您提供帮助。

  * **邮箱**: [support@sunoapi.org](mailto:support@sunoapi.org)
  * **文档**: [docs.sunoapi.org](https://docs.sunoapi.org)
  * **API状态**: 查看我们的状态页面了解实时API健康状况
</Info>

***

准备开始创建令人惊叹的AI音乐了吗？[获取您的API密钥](https://sunoapi.org/api-key)，立即开始创作！

# 生成音乐

> 使用AI模型生成带有或不带歌词的音乐。

## OpenAPI

````yaml cn/suno-api/suno-api-cn.json post /api/v1/generate
paths:
  path: /api/v1/generate
  method: post
  servers:
    - url: https://api.sunoapi.org
      description: API 服务器
  request:
    security:
      - title: BearerAuth
        parameters:
          query: {}
          header:
            Authorization:
              type: http
              scheme: bearer
              description: |-
                # 🔑 API 认证说明

                所有接口都需要通过 Bearer Token 方式进行认证。

                ## 获取 API Key

                1. 访问 [API Key 管理页面](https://sunoapi.org/api-key) 获取您的 API Key

                ## 使用方式

                在请求头中添加：

                ```
                Authorization: Bearer YOUR_API_KEY
                ```

                > **⚠️ 注意：**
                > - 请妥善保管您的 API Key，不要泄露给他人
                > - 如果怀疑 API Key 泄露，请立即在管理页面重置
          cookie: {}
    parameters:
      path: {}
      query: {}
      header: {}
      cookie: {}
    body:
      application/json:
        schemaArray:
          - type: object
            properties:
              prompt:
                allOf:
                  - type: string
                    description: >-
                      描述所需音频内容的提示词。  

                      - 自定义模式下（`customMode: true`）：当 `instrumental` 为 `false`
                      时必填。提示词将严格作为歌词使用并在生成的音轨中演唱。不同模型的字符限制：  
                        - **V3_5 和 V4**：最多3000字符  
                        - **V4_5、V4_5PLUS 和 V5**：最多5000字符  
                        示例："一段平静舒缓的钢琴曲，带有柔和的旋律"  
                      - 非自定义模式下（`customMode:
                      false`）：始终必填。提示词作为核心创意，歌词将根据它自动生成（不严格匹配输入），最多500字符。  
                        
                        示例："一段简短放松的钢琴曲"
                    example: 一段平静舒缓的钢琴曲，带有柔和的旋律
              style:
                allOf:
                  - type: string
                    description: |-
                      音乐风格或流派。  
                      - 在自定义模式下（`customMode: true`）必填。示例："爵士"、"古典"、"电子"。
                        - 对于 V3_5 和 V4 模型：最大长度：200字符。
                        - 对于 V4_5、V4_5PLUS 和 V5 模型：最大长度：1000字符。
                        示例："古典"  
                      - 在非自定义模式下（`customMode: false`）：留空。
                    example: 古典
              title:
                allOf:
                  - type: string
                    description: |-
                      生成音乐的标题。  
                      - 在自定义模式下（`customMode: true`）必填。最大长度：80字符。  
                        示例："宁静钢琴冥想"  
                      - 在非自定义模式下（`customMode: false`）：留空。
                    example: 宁静钢琴冥想
              customMode:
                allOf:
                  - type: boolean
                    description: >-
                      启用自定义模式进行高级音频生成设置。  

                      - 设为 `true` 使用自定义模式（需要提供 `style` 和 `title`；如果
                      `instrumental` 为 `false`，则需要提供 `prompt`）。如果 `instrumental`
                      为 `false`，提示词将严格用作歌词。  

                      - 设为 `false` 使用非自定义模式（只需要提供 `prompt`）。歌词将根据提示词自动生成。
                    example: true
              instrumental:
                allOf:
                  - type: boolean
                    description: >-
                      决定音频是否为纯音乐（无歌词）。  

                      - 在自定义模式下（`customMode: true`）：  
                        - 如果为 `true`：只需提供 `style` 和 `title`。  
                        - 如果为 `false`：需要提供 `style`、`title` 和 `prompt`（`prompt` 将作为精确歌词使用）。  
                      - 在非自定义模式下（`customMode: false`）：不影响必填字段（只需 `prompt`）。如果为
                      `false`，将自动生成歌词。
                    example: true
              model:
                allOf:
                  - type: string
                    description: |-
                      使用的模型版本，必须与源音频保持一致。  
                      - 可选择：  
                        - **`v5`**: 更卓越的音乐表现力，生成速度更快。  
                        - **`V4_5PLUS`**: V4.5+ 音色更丰富，新的创作方式，最长8分钟。  
                        - **`V4_5`**: V4.5 更智能的提示词，更快的生成速度，最长8分钟。  
                        - **`V4`**: V4 改进的人声质量，最长4分钟。  
                        - **`V3_5`**: V3.5 更好的歌曲结构，最长4分钟。
                    enum:
                      - V3_5
                      - V4
                      - V4_5
                      - V4_5PLUS
                      - V5
                    example: V3_5
              negativeTags:
                allOf:
                  - type: string
                    description: |-
                      需要在生成的音频中排除的音乐风格或特征。  
                      - 可选。用于避免特定风格。  
                        示例："重金属, 强节奏鼓点"
                    example: 重金属, 强节奏鼓点
              vocalGender:
                allOf:
                  - type: string
                    description: 期望的人声性别（可选）
                    enum:
                      - m
                      - f
                    example: m
              styleWeight:
                allOf:
                  - type: number
                    description: 风格指引权重，范围 0.00–1.00
                    minimum: 0
                    maximum: 1
                    multipleOf: 0.01
                    example: 0.65
              weirdnessConstraint:
                allOf:
                  - type: number
                    description: 创意发散/奇异度约束，范围 0.00–1.00
                    minimum: 0
                    maximum: 1
                    multipleOf: 0.01
                    example: 0.65
              audioWeight:
                allOf:
                  - type: number
                    description: 输入音频影响力权重（如适用），范围 0.00–1.00
                    minimum: 0
                    maximum: 1
                    multipleOf: 0.01
                    example: 0.65
              callBackUrl:
                allOf:
                  - type: string
                    format: uri
                    description: >-
                      接收任务完成通知的URL。回调过程有三个阶段：`text`（文本生成）、`first`（第一首完成）、`complete`（全部完成）。注意：某些情况下可能会跳过
                      `text` 和 `first` 阶段，直接返回 `complete`。


                      详细的回调格式和实现指南，请参见 [音乐生成回调](./generate-music-callbacks)

                      - 或者，您也可以使用获取音乐生成详情接口来轮询任务状态
                    example: https://api.example.com/callback
            required: true
            requiredProperties:
              - customMode
              - instrumental
              - callBackUrl
              - model
        examples:
          example:
            value:
              prompt: 一段平静舒缓的钢琴曲，带有柔和的旋律
              style: 古典
              title: 宁静钢琴冥想
              customMode: true
              instrumental: true
              model: V3_5
              negativeTags: 重金属, 强节奏鼓点
              vocalGender: m
              styleWeight: 0.65
              weirdnessConstraint: 0.65
              audioWeight: 0.65
              callBackUrl: https://api.example.com/callback
  response:
    '200':
      application/json:
        schemaArray:
          - type: object
            properties:
              code:
                allOf:
                  - type: integer
                    description: |-
                      # 状态码说明

                      - ✅ 200 - 请求成功
                      - ⚠️ 400 - 参数错误
                      - ⚠️ 401 - 没有访问权限
                      - ⚠️ 404 - 请求方式或者路径错误
                      - ⚠️ 405 - 调用超过限制
                      - ⚠️ 413 - 主题或者prompt过长
                      - ⚠️ 429 - 积分不足
                      - ⚠️ 430 - 您的调用频率过高，请稍后再试。
                      - ⚠️ 455 - 网站维护
                      - ❌ 500 - 服务器异常
                    example: 200
                    enum:
                      - 200
                      - 400
                      - 401
                      - 404
                      - 405
                      - 413
                      - 429
                      - 430
                      - 455
                      - 500
              msg:
                allOf:
                  - type: string
                    description: 当 code != 200 时，展示错误信息
                    example: success
              data:
                allOf:
                  - type: object
                    properties:
                      taskId:
                        type: string
                        description: 任务ID，用于后续查询任务状态
                        example: 5c79****be8e
            refIdentifier: '#/components/schemas/ApiResponse'
        examples:
          example:
            value:
              code: 200
              msg: success
              data:
                taskId: 5c79****be8e
        description: 请求成功
    '500':
      _mintlify/placeholder:
        schemaArray:
          - type: any
            description: 服务器异常
        examples: {}
        description: 服务器异常
  deprecated: false
  type: path
components:
  schemas: {}

````
curl --request POST \
  --url https://api.sunoapi.org/api/v1/generate \
  --header 'Authorization: Bearer <token>' \
  --header 'Content-Type: application/json' \
  --data '{
  "prompt": "一段平静舒缓的钢琴曲，带有柔和的旋律",
  "style": "古典",
  "title": "宁静钢琴冥想",
  "customMode": true,
  "instrumental": true,
  "model": "V3_5",
  "negativeTags": "重金属, 强节奏鼓点",
  "vocalGender": "m",
  "styleWeight": 0.65,
  "weirdnessConstraint": 0.65,
  "audioWeight": 0.65,
  "callBackUrl": "https://api.example.com/callback"
}'



{
  "code": 200,
  "msg": "success",
  "data": {
    "taskId": "5c79****be8e"
  }
}

This response does not have an example.


# 音乐生成回调

> 当音乐生成任务完成时，系统将通过POST请求将结果发送到您提供的回调URL

当您向音乐生成API提交任务时，可以使用 `callBackUrl` 参数设置回调URL。当任务完成时，系统会自动将结果推送到您指定的地址。

## 回调机制概述

<Info>
  回调机制无需轮询API查询任务状态，系统会主动将任务完成结果推送到您的服务器。
</Info>

### 回调时机

系统会在以下情况发送回调通知：

* 音乐生成任务成功完成
* 音乐生成任务失败
* 任务处理过程中发生错误

### 回调方式

* **HTTP方法**: POST
* **Content Type**: application/json
* **超时设置**: 15秒

## 回调请求格式

任务完成时，系统会向您的 `callBackUrl` 发送以下格式的POST请求：

<CodeGroup>
  ```json 成功回调 theme={null}
  {
    "code": 200,
    "msg": "All generated successfully.",
    "data": {
      "callbackType": "complete",
      "task_id": "2fac****9f72",
      "data": [
        {
          "id": "8551****662c",
          "audio_url": "https://example.cn/****.mp3",
          "source_audio_url": "https://example.cn/****.mp3",
          "stream_audio_url": "https://example.cn/****",
          "source_stream_audio_url": "https://example.cn/****",
          "image_url": "https://example.cn/****.jpeg",
          "source_image_url": "https://example.cn/****.jpeg",
          "prompt": "[Verse] Night city lights shining bright",
          "model_name": "chirp-v3-5",
          "title": "Iron Man",
          "tags": "electrifying, rock",
          "createTime": "2025-01-01 00:00:00",
          "duration": 198.44
        },
        {
          "id": "bd15****1873",
          "audio_url": "https://example.cn/****.mp3",
          "source_audio_url": "https://example.cn/****.mp3",
          "stream_audio_url": "https://example.cn/****",
          "source_stream_audio_url": "https://example.cn/****",
          "image_url": "https://example.cn/****.jpeg",
          "source_image_url": "https://example.cn/****.jpeg",
          "prompt": "[Verse] Night city lights shining bright",
          "model_name": "chirp-v3-5",
          "title": "Iron Man",
          "tags": "electrifying, rock",
          "createTime": "2025-01-01 00:00:00",
          "duration": 228.28
        }
      ]
    }
  }
  ```

  ```json 失败回调 theme={null}
  {
    "code": 400,
    "msg": "音乐生成失败",
    "data": {
      "callbackType": "error",
      "task_id": "2fac****9f72",
      "data": null
    }
  }
  ```
</CodeGroup>

## 状态码说明

<ParamField path="code" type="integer" required>
  回调状态码，表示任务处理结果：

  | 状态码 | 说明                |
  | --- | ----------------- |
  | 200 | 成功 - 音乐生成完成       |
  | 400 | 请求错误 - 参数错误、内容违规等 |
  | 451 | 下载失败 - 无法下载相关文件   |
  | 500 | 服务器错误 - 请稍后重试     |
</ParamField>

<ParamField path="msg" type="string" required>
  状态消息，提供详细的状态描述
</ParamField>

<ParamField path="data.callbackType" type="string" required>
  回调类型，表示当前回调的阶段：

  * `text`: 文本生成完成
  * `first`: 第一首音乐完成
  * `complete`: 所有音乐完成
  * `error`: 任务失败
</ParamField>

<ParamField path="data.task_id" type="string" required>
  任务ID，与您提交任务时返回的taskId一致
</ParamField>

<ParamField path="data.data" type="array">
  音乐生成结果信息，成功时返回
</ParamField>

<ParamField path="data.data[].id" type="string">
  音乐唯一标识符
</ParamField>

<ParamField path="data.data[].audio_url" type="string">
  生成的音频文件URL
</ParamField>

<ParamField path="data.data[].source_audio_url" type="string">
  原始音频文件URL
</ParamField>

<ParamField path="data.data[].stream_audio_url" type="string">
  流式音频URL
</ParamField>

<ParamField path="data.data[].source_stream_audio_url" type="string">
  原始流式音频URL
</ParamField>

<ParamField path="data.data[].image_url" type="string">
  封面图片URL
</ParamField>

<ParamField path="data.data[].source_image_url" type="string">
  原始封面图片URL
</ParamField>

<ParamField path="data.data[].prompt" type="string">
  生成提示词/歌词
</ParamField>

<ParamField path="data.data[].model_name" type="string">
  使用的模型名称
</ParamField>

<ParamField path="data.data[].title" type="string">
  音乐标题
</ParamField>

<ParamField path="data.data[].tags" type="string">
  音乐标签
</ParamField>

<ParamField path="data.data[].createTime" type="string">
  创建时间
</ParamField>

<ParamField path="data.data[].duration" type="number">
  音频时长（秒）
</ParamField>

## 回调接收示例

以下是主流编程语言接收回调的示例代码：

<Tabs>
  <Tab title="Node.js">
    ```javascript  theme={null}
    const express = require('express');
    const app = express();

    app.use(express.json());

    app.post('/generate-music-callback', (req, res) => {
      const { code, msg, data } = req.body;
      
      console.log('收到音乐生成回调:', {
        taskId: data.task_id,
        callbackType: data.callbackType,
        status: code,
        message: msg
      });
      
      if (code === 200) {
        // 任务成功完成
        console.log('音乐生成完成');
        const musicData = data.data || [];
        
        console.log(`生成了 ${musicData.length} 首音乐:`);
        musicData.forEach((music, index) => {
          console.log(`音乐 ${index + 1}:`);
          console.log(`  标题: ${music.title}`);
          console.log(`  时长: ${music.duration}秒`);
          console.log(`  标签: ${music.tags}`);
          console.log(`  音频URL: ${music.audio_url}`);
          console.log(`  封面URL: ${music.image_url}`);
        });
        
        // 处理生成的音乐
        // 可以下载音频文件、保存到本地等
        
      } else {
        // 任务失败
        console.log('音乐生成失败:', msg);
        
        // 处理失败情况...
        if (code === 400) {
          console.log('参数错误或内容违规');
        } else if (code === 451) {
          console.log('文件下载失败');
        } else if (code === 500) {
          console.log('服务器内部错误');
        }
      }
      
      // 返回200状态码确认收到回调
      res.status(200).json({ status: 'received' });
    });

    app.listen(3000, () => {
      console.log('回调服务器运行在端口 3000');
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python  theme={null}
    from flask import Flask, request, jsonify
    import requests

    app = Flask(__name__)

    @app.route('/generate-music-callback', methods=['POST'])
    def handle_callback():
        data = request.json
        
        code = data.get('code')
        msg = data.get('msg')
        callback_data = data.get('data', {})
        task_id = callback_data.get('task_id')
        callback_type = callback_data.get('callbackType')
        music_data = callback_data.get('data', [])
        
        print(f"收到音乐生成回调: {task_id}, 类型: {callback_type}, 状态: {code}, 消息: {msg}")
        
        if code == 200:
            # 任务成功完成
            print("音乐生成完成")
            
            print(f"生成了 {len(music_data)} 首音乐:")
            for i, music in enumerate(music_data):
                print(f"音乐 {i + 1}:")
                print(f"  标题: {music.get('title')}")
                print(f"  时长: {music.get('duration')}秒")
                print(f"  标签: {music.get('tags')}")
                print(f"  音频URL: {music.get('audio_url')}")
                print(f"  封面URL: {music.get('image_url')}")
                
                # 下载音频文件示例
                try:
                    audio_url = music.get('audio_url')
                    if audio_url:
                        response = requests.get(audio_url)
                        if response.status_code == 200:
                            filename = f"generated_music_{task_id}_{i + 1}.mp3"
                            with open(filename, "wb") as f:
                                f.write(response.content)
                            print(f"音频已保存为 {filename}")
                except Exception as e:
                    print(f"音频下载失败: {e}")
                    
        else:
            # 任务失败
            print(f"音乐生成失败: {msg}")
            
            # 处理失败情况...
            if code == 400:
                print("参数错误或内容违规")
            elif code == 451:
                print("文件下载失败")
            elif code == 500:
                print("服务器内部错误")
        
        # 返回200状态码确认收到回调
        return jsonify({'status': 'received'}), 200

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=3000)
    ```
  </Tab>

  <Tab title="PHP">
    ```php  theme={null}
    <?php
    header('Content-Type: application/json');

    // 获取POST数据
    $input = file_get_contents('php://input');
    $data = json_decode($input, true);

    $code = $data['code'] ?? null;
    $msg = $data['msg'] ?? '';
    $callbackData = $data['data'] ?? [];
    $taskId = $callbackData['task_id'] ?? '';
    $callbackType = $callbackData['callbackType'] ?? '';
    $musicData = $callbackData['data'] ?? [];

    error_log("收到音乐生成回调: $taskId, 类型: $callbackType, 状态: $code, 消息: $msg");

    if ($code === 200) {
        // 任务成功完成
        error_log("音乐生成完成");
        
        error_log("生成了 " . count($musicData) . " 首音乐:");
        foreach ($musicData as $index => $music) {
            error_log("音乐 " . ($index + 1) . ":");
            error_log("  标题: " . ($music['title'] ?? ''));
            error_log("  时长: " . ($music['duration'] ?? 0) . "秒");
            error_log("  标签: " . ($music['tags'] ?? ''));
            error_log("  音频URL: " . ($music['audio_url'] ?? ''));
            error_log("  封面URL: " . ($music['image_url'] ?? ''));
            
            // 下载音频文件示例
            try {
                $audioUrl = $music['audio_url'] ?? '';
                if ($audioUrl) {
                    $audioContent = file_get_contents($audioUrl);
                    if ($audioContent !== false) {
                        $filename = "generated_music_{$taskId}_" . ($index + 1) . ".mp3";
                        file_put_contents($filename, $audioContent);
                        error_log("音频已保存为 $filename");
                    }
                }
            } catch (Exception $e) {
                error_log("音频下载失败: " . $e->getMessage());
            }
        }
        
    } else {
        // 任务失败
        error_log("音乐生成失败: $msg");
        
        // 处理失败情况...
        if ($code === 400) {
            error_log("参数错误或内容违规");
        } elseif ($code === 451) {
            error_log("文件下载失败");
        } elseif ($code === 500) {
            error_log("服务器内部错误");
        }
    }

    // 返回200状态码确认收到回调
    http_response_code(200);
    echo json_encode(['status' => 'received']);
    ?>
    ```
  </Tab>
</Tabs>

## 最佳实践

<Tip>
  ### 回调URL配置建议

  1. **使用HTTPS**: 确保回调URL使用HTTPS协议，保障数据传输安全
  2. **验证来源**: 在回调处理中验证请求来源的合法性
  3. **幂等处理**: 同一个taskId可能收到多次回调，确保处理逻辑是幂等的
  4. **快速响应**: 回调处理应尽快返回200状态码，避免超时
  5. **异步处理**: 复杂的业务逻辑应异步处理，避免阻塞回调响应
  6. **音频处理**: 音频下载和处理应在异步任务中进行，避免阻塞回调响应
</Tip>

<Warning>
  ### 重要提醒

  * 回调URL必须是公网可访问的地址
  * 服务器必须在15秒内响应，否则视为超时
  * 连续3次重试失败后，系统将停止发送回调
  * 请确保回调处理逻辑的稳定性，避免因异常导致回调失败
  * 生成的音频URL可能有时效限制，建议及时下载保存
  * 注意内容合规性，避免因违规导致生成失败
</Warning>

## 故障排查

如果您没有收到回调通知，请检查以下内容：

<AccordionGroup>
  <Accordion title="网络连接问题">
    * 确认回调URL可以从公网访问
    * 检查防火墙设置，确保不会阻拦入站请求
    * 验证域名解析是否正确
  </Accordion>

  <Accordion title="服务器响应问题">
    * 确保服务器在15秒内返回HTTP 200状态码
    * 检查服务器日志是否有错误信息
    * 验证接口路径和HTTP方法是否正确
  </Accordion>

  <Accordion title="内容格式问题">
    * 确认接收到的POST请求体为JSON格式
    * 检查Content-Type是否为application/json
    * 验证JSON解析是否正确
  </Accordion>

  <Accordion title="音频处理问题">
    * 确认音频URL是否可访问
    * 检查音频下载权限和网络连接
    * 验证音频保存路径和权限
    * 注意音频内容是否符合内容政策
  </Accordion>
</AccordionGroup>

## 替代方案

如果您无法使用回调机制，也可以使用轮询方式：

<Card title="轮询查询结果" icon="radar" href="/suno-api/get-music-generation-details">
  使用获取音乐生成详情接口定时查询任务状态，建议每30秒查询一次。
</Card>


