import Vue from 'vue'
import MinRequest from '@/utils/MinRequest'
import globalConfig from '@/config'
import requestQueue from '@/utils/requestQueue'
import errorHandler from '@/utils/errorHandler'
import tokenManager from '@/utils/tokenManager'

const minRequest = new MinRequest()

// Request interceptor with token management
minRequest.interceptors.request((request) => {
	const user = Vue.prototype.$store.getters.user
	// Prioritize token, then ApiToken (compatibility)
	const token = user?.token || user?.ApiToken || tokenManager.getToken();

	console.log('ðŸ“¤ API Request Interceptor:');
	console.log('  - URL:', request.url);
	console.log('  - Token exists:', !!token);

	if (token) {
		request.header = {
			...request.header,
			'Authorization': `Bearer ${token}`
		}
		console.log('  - Authorization header added');
	} else {
		console.log('  - âš ï¸ No token, skipping Authorization header');
	}
	return request
})

// Response interceptor with error handling and token refresh
minRequest.interceptors.response(async (response) => {
	console.log('ðŸ“¥ API Response Interceptor:');
	console.log('  - Status Code:', response.statusCode);
	console.log('  - Response Data:', response.data);

	// 401 Unauthorized - Handle with automatic token refresh
	if (response.statusCode === 401) {
		console.log('ðŸ” Received 401 Unauthorized, attempting token refresh...');

		try {
			// Refresh token using TokenManager
			const newToken = await tokenManager.refreshToken(minRequest.apis);

			// Update token in Vuex store
			const user = Vue.prototype.$store.getters.user;
			if (user) {
				Vue.prototype.$store.commit('login', {
					...user,
					token: newToken,
					ApiToken: newToken
				});
			}

			console.log('âœ… Token refreshed successfully, retry not implemented yet');
			// Note: Actual request retry would require restructuring the interceptor
			// For now, the token is refreshed but the original request fails
			// The next request will use the new token
		} catch (error) {
			console.error('âŒ Token refresh failed:', error);
			// ErrorHandler will handle the redirect to login
			errorHandler.handle(error, '401 Token Refresh');
		}
	}

	return response.data
})

// Set default configuration
minRequest.setConfig((config) => {
	config.baseURL = globalConfig.baseUrl
	return config
})

export default {
	// è¿™é‡Œç»Ÿä¸€ç®¡ç†apiè¯·æ±‚
	apis: {
		// ============= è®¤è¯ç›¸å…³æŽ¥å£ =============
		// å¾®ä¿¡å°ç¨‹åºç™»å½• (æ—§ç‰ˆæœ¬ï¼Œå…¼å®¹ä¿ç•™)
		wechatLogin(params) {
			return minRequest.post('/auth/wechat-login', params)
		},
		// å¾®ä¿¡å°ç¨‹åºæŽˆæƒç™»å½• (æ–°ç‰ˆæœ¬ï¼Œæ”¯æŒæ‰‹æœºå·èŽ·å–)
		wechatAuth(params) {
			return minRequest.post('/auth/wechat-auth', params)
		},
		// æ£€æŸ¥ç™»å½•çŠ¶æ€
		checkLoginState() {
			return minRequest.get('/auth/check')
		},
		// Refresh token
		refreshToken() {
			return minRequest.post('/auth/refresh-token')
		},
		// é€€å‡ºç™»å½•
		logout() {
			return minRequest.post('/auth/logout')
		},

		// ============= ç”¨æˆ·ç›¸å…³æŽ¥å£ =============
		// èŽ·å–ç”¨æˆ·ä¿¡æ¯
		getUserProfile() {
			return minRequest.get('/user/profile')
		},
		// æ›´æ–°ç”¨æˆ·ä¿¡æ¯
		updateUserProfile(params) {
			return minRequest.put('/user/profile', params)
		},
		// æ¯æ—¥ç­¾åˆ°
		checkin() {
			return minRequest.post('/user/checkin')
		},
		// èŽ·å–ç”¨æˆ·ç»Ÿè®¡
		getUserStats() {
			return minRequest.get('/user/stats')
		},
		// ä¿®æ”¹å¯†ç 
		changePassword(params) {
			return minRequest.put('/user/password', params)
		},

		// ============= éŸ³ä¹ç”ŸæˆæŽ¥å£ =============
		// åˆ›å»ºéŸ³ä¹ç”Ÿæˆä»»åŠ¡
		createMusicTask(params) {
			return minRequest.post('/user/music/generate', params)
		},
		// èŽ·å–ä»»åŠ¡è¯¦æƒ…
		getMusicTask(id) {
			return minRequest.get(`/user/music/${id}`)
		},
		// èŽ·å–ä»»åŠ¡çŠ¶æ€
		getMusicTaskStatus(id) {
			return minRequest.get(`/user/music/${id}/status`)
		},
		// èŽ·å–ç”¨æˆ·éŸ³ä¹ä»»åŠ¡åˆ—è¡¨
		getMusicTasks(params) {
			return minRequest.get('/user/music/list', params)
		},
		// åˆ é™¤éŸ³ä¹ä»»åŠ¡
		deleteMusicTask(id) {
			return minRequest.delete(`/user/music/${id}`)
		},

		// ============= AIæ­Œè¯ç”ŸæˆæŽ¥å£ =============
		// ç”ŸæˆAIæ­Œè¯
		generateLyrics(params) {
			return minRequest.post('/user/ai/lyrics/generate', params)
		},
		// èŽ·å–æ­Œè¯ç”ŸæˆåŽ†å²
		getLyricsHistory(params) {
			return minRequest.get('/user/ai/lyrics/history', params)
		},
		// èŽ·å–æ­Œè¯è¯¦æƒ…
		getLyricsDetail(requestId) {
			return minRequest.get(`/user/ai/lyrics/${requestId}`)
		},
		// è¯„ä»·æ­Œè¯
		rateLyrics(requestId, params) {
			return minRequest.post(`/user/ai/lyrics/${requestId}/rate`, params)
		},
		// æ”¶è—/å–æ¶ˆæ”¶è—æ­Œè¯
		toggleLyricsFavorite(requestId) {
			return minRequest.post(`/user/ai/lyrics/${requestId}/favorite`)
		},
		// æ£€æŸ¥GeminiæœåŠ¡çŠ¶æ€
		checkGeminiStatus() {
			return minRequest.get('/user/ai/gemini/status')
		},

		// ============= ä½œå“ç®¡ç†æŽ¥å£ =============
		// èŽ·å–ç”¨æˆ·ä½œå“åˆ—è¡¨
		getUserWorks(params) {
			return minRequest.get('/work/list', params)
		},
		// èŽ·å–å…¬å¼€ä½œå“åˆ—è¡¨
		getPublicWorks(params) {
			return minRequest.get('/work/public', params)
		},
		// èŽ·å–ä½œå“è¯¦æƒ…
		getWorkDetail(id) {
			return minRequest.get(`/work/${id}`)
		},
		// æ›´æ–°ä½œå“ä¿¡æ¯
		updateWork(id, params) {
			return minRequest.put(`/work/${id}`, params)
		},
		// åˆ é™¤ä½œå“
		deleteWork(id) {
			return minRequest.delete(`/work/${id}`)
		},
		// åˆ†äº«ä½œå“
		shareWork(id, params) {
			return minRequest.post(`/work/${id}/share`, params)
		},
		// ç‚¹èµžä½œå“
		likeWork(id) {
			return minRequest.post(`/work/${id}/like`)
		},

		// ============= ç‚¹æ•°ç³»ç»ŸæŽ¥å£ =============
		// Get credit balance (with request deduplication)
		getCreditBalance() {
			const key = 'creditBalance';
			return requestQueue.enqueue(key, () => minRequest.get('/user/credit/balance'));
		},
		// èŽ·å–ç‚¹æ•°è®°å½•
		getCreditLogs(params) {
			return minRequest.get('/user/credit/logs', params)
		},
		// èŽ·å–ç‚¹æ•°ç»Ÿè®¡
		getCreditStats() {
			return minRequest.get('/user/credit/stats')
		},
		// èŽ·å–ç‚¹æ•°å¥—é¤
		getCreditPackages() {
			return minRequest.get('/user/credit/packages')
		},
		// æ¶ˆè´¹ç‚¹æ•°
		consumeCredit(params) {
			return minRequest.post('/user/credit/consume', params)
		},
		// å¥–åŠ±ç‚¹æ•°
		rewardCredit(params) {
			return minRequest.post('/user/credit/reward', params)
		},

		// ============= ç´ æç®¡ç†æŽ¥å£ =============
		// èŽ·å–ç´ æåˆ—è¡¨ï¼ˆæ­Œè¯æ¨¡æ¿ã€çµæ„ŸæŽ¨èç­‰ï¼‰
		getMaterials(params) {
			return minRequest.get('/material/list', params)
		},
		// èŽ·å–æŽ¨èç´ æ
		getRecommendedMaterials(params) {
			return minRequest.get('/material/recommended', params)
		},
		// èŽ·å–ç´ æè¯¦æƒ…
		getMaterialDetail(id) {
			return minRequest.get(`/material/${id}`)
		},
		// æ”¶è—/å–æ¶ˆæ”¶è—ç´ æ
		toggleMaterialFavorite(id) {
			return minRequest.post(`/material/${id}/favorite`)
		},
		// ä½¿ç”¨ç´ æ
		useMaterial(params) {
			return minRequest.post('/material/use', params)
		},
		// èŽ·å–é¦–é¡µæ•°æ®ï¼ˆæç¤ºè¯æ¨¡æ¿ï¼‰
		getHomePageData() {
			return minRequest.get('/material/home-data')
		},
		// èŽ·å–çƒ­é—¨æŽ¨èä½œå“ï¼ˆæ—§æŽ¥å£ï¼Œä¿ç•™å…¼å®¹ï¼‰
		getHotRecommendationsOld(params) {
			return minRequest.get('/work/hot-recommendations', params)
		},

		// ============= Bannerè½®æ’­å›¾ç®¡ç†æŽ¥å£ =============
		// Get banner list (with request deduplication)
		getBanners() {
			const key = 'banners';
			return requestQueue.enqueue(key, () => minRequest.get('/public/banner/list'));
		},
		// Get active banners (with request deduplication)
		getActiveBanners() {
			const key = 'activeBanners';
			return requestQueue.enqueue(key, () => minRequest.get('/banners/active'));
		},
		// åˆ›å»ºè½®æ’­å›¾
		createBanner(params) {
			return minRequest.post('/banner/create', params)
		},
		// æ›´æ–°è½®æ’­å›¾
		updateBanner(id, params) {
			return minRequest.put(`/banner/${id}`, params)
		},
		// åˆ é™¤è½®æ’­å›¾
		deleteBanner(id) {
			return minRequest.delete(`/banner/${id}`)
		},
		// æ›´æ–°è½®æ’­å›¾çŠ¶æ€ï¼ˆå¯ç”¨/ç¦ç”¨ï¼‰
		toggleBannerStatus(id) {
			return minRequest.post(`/banner/${id}/toggle`)
		},
		// æ›´æ–°è½®æ’­å›¾æŽ’åº
		updateBannerSort(sortData) {
			return minRequest.post('/banner/sort', sortData)
		},

		// ============= åˆ›ä½œæç¤ºè¯ç®¡ç†æŽ¥å£ =============
		// Get active prompt templates (with request deduplication)
		getActivePromptTemplates(params) {
			const key = requestQueue.generateKey('promptTemplates', params);
			console.log('ðŸ“‹ Calling prompt template API:', '/public/prompt-template/list', params);
			return requestQueue.enqueue(key, () => minRequest.get('/public/prompt-template/list', params || {}));
		},
		// èŽ·å–æ‰€æœ‰æç¤ºè¯åˆ—è¡¨ï¼ˆç®¡ç†åŽå°ç”¨ï¼‰
		getPromptTemplates(params) {
			return minRequest.get('/', {}).then(response => {
				if (response.code === 200 && response.data.promptTemplates) {
					const templates = response.data.promptTemplates.templates;
					if (params && params.category && params.category !== 'å…¨éƒ¨') {
						return {
							...response,
							data: templates.filter(t => t.category === params.category)
						};
					}
					return { ...response, data: templates };
				}
				return response;
			});
		},
		// æ ¹æ®æ ‡ç­¾èŽ·å–æç¤ºè¯
		getPromptTemplatesByTag(tag) {
			return minRequest.get(`/prompt-template/tag/${tag}`)
		},
		// åˆ›å»ºæç¤ºè¯
		createPromptTemplate(params) {
			return minRequest.post('/prompt-template/create', params)
		},
		// æ›´æ–°æç¤ºè¯
		updatePromptTemplate(id, params) {
			return minRequest.put(`/prompt-template/${id}`, params)
		},
		// åˆ é™¤æç¤ºè¯
		deletePromptTemplate(id) {
			return minRequest.delete(`/prompt-template/${id}`)
		},
		// æ›´æ–°æç¤ºè¯çŠ¶æ€ï¼ˆå¯ç”¨/ç¦ç”¨ï¼‰
		togglePromptTemplateStatus(id) {
			return minRequest.post(`/prompt-template/${id}/toggle`)
		},
		// æ›´æ–°æç¤ºè¯æŽ’åº
		updatePromptTemplateSort(sortData) {
			return minRequest.post('/prompt-template/sort', sortData)
		},
		// æ‰¹é‡æ“ä½œæç¤ºè¯
		batchPromptTemplateOperation(params) {
			return minRequest.post('/prompt-template/batch', params)
		},
		// è®°å½•æç¤ºè¯ä½¿ç”¨ç»Ÿè®¡
		trackPromptTemplateUsage(params) {
			console.log('ðŸ“Š è®°å½•æç¤ºè¯ä½¿ç”¨ç»Ÿè®¡:', params);
			return minRequest.post('/public/prompt-template/usage', params);
		},

		// ============= AIçµæ„Ÿæ‰©å±•æŽ¥å£ =============
		// AIçµæ„Ÿæ‰©å±•
		expandInspiration(params) {
			return minRequest.post('/user/ai/expand-inspiration', params)
		},

		// ============= åˆ›ä½œæ¨¡æ¿æŽ¥å£ =============
		// èŽ·å–å…¬å¼€çš„æ¨¡æ¿åˆ—è¡¨
		getPromptTemplates(category) {
			console.log('ðŸ“‹ è°ƒç”¨æ¨¡æ¿åˆ—è¡¨API:', '/public/prompt-template/list', { category });
			const params = category ? { category } : {};
			return minRequest.get('/public/prompt-template/list', params);
		},
		// èŽ·å–æ¨¡æ¿åˆ†ç±»
		getPromptCategories() {
			console.log('ðŸ“‹ è°ƒç”¨åˆ†ç±»åˆ—è¡¨API:', '/public/prompt-template/categories');
			return minRequest.get('/public/prompt-template/categories');
		},
		// è®°å½•æ¨¡æ¿ä½¿ç”¨
		recordTemplateUsage(templateId) {
			return minRequest.post('/public/prompt-template/usage', { templateId })
		},
		// ç®¡ç†åŽå°ï¼šèŽ·å–æ¨¡æ¿åˆ—è¡¨
		getAdminPromptTemplates(params) {
			return minRequest.get('/prompt-template/admin/list', params)
		},
		// åˆ›å»ºæ¨¡æ¿
		createPromptTemplate(params) {
			return minRequest.post('/prompt-template/create', params)
		},
		// æ›´æ–°æ¨¡æ¿
		updatePromptTemplate(id, params) {
			return minRequest.patch(`/prompt-template/${id}`, params)
		},
		// åˆ é™¤æ¨¡æ¿
		deletePromptTemplate(id) {
			return minRequest.delete(`/prompt-template/${id}`)
		},
		// åˆ‡æ¢æ¨¡æ¿å¯ç”¨çŠ¶æ€
		togglePromptTemplate(id) {
			return minRequest.post(`/prompt-template/${id}/toggle`)
		},

		// ============= çƒ­é—¨æŽ¨èç®¡ç†æŽ¥å£ =============
		// Get hot recommendations (with request deduplication)
		getHotRecommendations(params) {
			const key = requestQueue.generateKey('hotRecommendations', params);
			return requestQueue.enqueue(key, () => minRequest.get('/public/hot-recommendation/list', params));
		},
		// èŽ·å–æŽ¨èåˆ†ç±»æ ‡ç­¾
		getRecommendationCategories() {
			return minRequest.get('/public/hot-recommendation/categories')
		},
		// æ ¹æ®åˆ†ç±»èŽ·å–æŽ¨èéŸ³ä¹
		getRecommendationsByCategory(categoryId, params) {
			return minRequest.get(`/public/hot-recommendation/category/${categoryId}`, params)
		},
		// èŽ·å–æ‰€æœ‰æŽ¨èéŸ³ä¹ï¼ˆç®¡ç†åŽå°ç”¨ï¼‰
		getAllRecommendations(params) {
			return minRequest.get('/hot-recommendation/admin/list', params)
		},
		// åˆ›å»ºæŽ¨èéŸ³ä¹
		createRecommendation(params) {
			return minRequest.post('/hot-recommendation/create', params)
		},
		// æ›´æ–°æŽ¨èéŸ³ä¹
		updateRecommendation(id, params) {
			return minRequest.put(`/hot-recommendation/${id}`, params)
		},
		// åˆ é™¤æŽ¨èéŸ³ä¹
		deleteRecommendation(id) {
			return minRequest.delete(`/hot-recommendation/${id}`)
		},
		// æ›´æ–°æŽ¨èéŸ³ä¹çŠ¶æ€ï¼ˆå¯ç”¨/ç¦ç”¨ï¼‰
		toggleRecommendationStatus(id) {
			return minRequest.post(`/hot-recommendation/${id}/toggle`)
		},
		// æ›´æ–°æŽ¨èéŸ³ä¹æŽ’åº
		updateRecommendationSort(sortData) {
			return minRequest.post('/hot-recommendation/sort', sortData)
		},
		// æ‰¹é‡æ“ä½œæŽ¨èéŸ³ä¹
		batchRecommendationOperation(params) {
			return minRequest.post('/hot-recommendation/batch', params)
		},
		// è®°å½•éŸ³ä¹æ’­æ”¾ç»Ÿè®¡
		trackMusicPlay(params) {
			return minRequest.post('/public/hot-recommendation/play', params)
		},

		// ============= æ”¯ä»˜ç›¸å…³æŽ¥å£ =============
		// åˆ›å»ºè®¢å•
		createOrder(params) {
			return minRequest.post('/user/payment/order', params)
		},
		// åˆ›å»ºå¾®ä¿¡æ”¯ä»˜
		createWechatPayment(params) {
			return minRequest.post('/user/payment/wechat-pay', params)
		},
		// èŽ·å–è®¢å•è¯¦æƒ…
		getOrderDetail(id) {
			return minRequest.get(`/user/payment/order/${id}`)
		},
		// èŽ·å–è®¢å•åˆ—è¡¨
		getOrders(params) {
			return minRequest.get('/user/payment/orders', params)
		},
		// æŸ¥è¯¢è®¢å•çŠ¶æ€
		queryOrderStatus(orderNo) {
			return minRequest.get(`/user/payment/query/${orderNo}`)
		},
		// å–æ¶ˆè®¢å•
		cancelOrder(orderNo) {
			return minRequest.post(`/user/payment/cancel/${orderNo}`)
		},

		// ============= æ–‡ä»¶ç®¡ç†æŽ¥å£ =============
		// æ–‡ä»¶ä¸Šä¼ 
		uploadFile(filePath, fileName, fileType, purpose) {
			const user = Vue.prototype.$store.getters.user
			return new Promise((resolve, reject) => {
				uni.uploadFile({
					url: globalConfig.baseUrl + '/user/files/upload',
					filePath: filePath,
					name: 'file',
					header: {
						'Authorization': `Bearer ${user.ApiToken}`
					},
					formData: {
						type: fileType || 'audio',
						purpose: purpose || 'music_upload'
					},
					success: (res) => {
						if(typeof res.data === 'string') {
							res.data = JSON.parse(res.data)
						}
						if(res.data.code === 200) {
							resolve(res.data)
						} else {
							reject(res.data)
						}
					},
					fail: (err) => {
						reject({
							code: 500,
							message: err.errMsg || 'ä¸Šä¼ å¤±è´¥'
						})
					}
				})
			})
		},
		// èŽ·å–æ–‡ä»¶ä¿¡æ¯
		getFileInfo(id) {
			return minRequest.get(`/user/files/${id}`)
		},
		// æ–‡ä»¶ä¸‹è½½
		downloadFile(id) {
			return minRequest.get(`/user/files/${id}/download`)
		},
		// æ–‡ä»¶é¢„è§ˆ
		previewFile(id) {
			return minRequest.get(`/user/files/${id}/preview`)
		},

		listUser(params) {
			return minRequest.get('/User/GetUserList',params)
		},
		listRole() {
			return minRequest.get('/User/GetRoleList')
		},
		settingRole(params){
			return minRequest.post('/User/SettingRole',params)
		},
		listContractor(params) {
			return minRequest.get('/Task/GetContractorList',params)
		},
		getContractor(params) {
			return minRequest.get('/Task/GetContractorInfo',params)
		},
		listStaff(params) {
			return minRequest.get('/Task/GetStaffList',params)
		},
		getStaff(params) {
			return minRequest.get('/Task/GetStaffInfo',params)
		},
		saveStaff(params){
			return minRequest.post('/Task/StaffSave',params)
		},
		saveContractor(params){
			return minRequest.post('/Task/ContractorSave',params)
		},
		delStaff(params){
			return minRequest.post('/Task/DelStaffInfo',params)
		},
		userPwdModify(params) {
			return minRequest.post('/post/user/pwd/modify', params)
		},
		// é¡¹ç›®å®¡æ‰¹åˆ—è¡¨
		listAuditProject() {
			return minRequest.get('/get/audit/project/list')
		},
		// ç”¨æˆ·å®¡æ‰¹åˆ—è¡¨
		listAuditUser() {
			return minRequest.get('/get/audit/user/list')
		},
		// äº‹æ•…æ¨¡å—æŽ¥å£
		// èŽ·å–äº‹æ•…åˆ—è¡¨
		getEventList(params) {
			return minRequest.get('/Event/GetEventList', params)
		},
		// èŽ·å–äº‹æ•…è¯¦æƒ…
		getEventInfo(eventId) {
			return minRequest.get('/Event/GetEventInfo', { eventId })
		},
		// ä¿å­˜äº‹æ•…ä¿¡æ¯
		saveEvent(params) {
			return minRequest.post('/Event/EventSave', params)
		},
		getEventDays() {
			return minRequest.get('/Event/GetDays')
		},
		// ä»»åŠ¡æ¨¡å—æŽ¥å£
		// èŽ·å–ä»»åŠ¡åˆ—è¡¨
		getTaskList(params) {
			return minRequest.get('/Task/GetTaskList', params)
		},
		// èŽ·å–åˆ†ç»„ä»»åŠ¡è¯¦æƒ…
		getGroupTaskInfo(taskId) {
			return minRequest.get('/Task/GetGroupTaskInfo', { taskId })
		},
		// èŽ·å–simpleä»»åŠ¡è¯¦æƒ…
		getSimpleTaskInfo(taskId) {
			return minRequest.get('/Task/GetSimpleTaskInfo', { taskId })
		},
		// èŽ·å–ä»»åŠ¡è¯¦æƒ…
		getTaskInfo(taskId) {
			return minRequest.get('/Task/GetTaskInfo', { taskId })
		},
		// ä¿å­˜ä»»åŠ¡ä¿¡æ¯
		saveTask(params) {
			return minRequest.post('/Task/SaveTask', params)
		},
		loadBarCharts(params){
			return minRequest.get('/Event/GetChartsJson', params)
		},
		loadTableCharts(params){
			return minRequest.get('/Event/GetChartsByYearJson', params)
		},
		loadEventByMonth(params){
			return minRequest.get('/Event/GetChartsByMonthJson',params)
		},
		loadEventByDay(params){
			return minRequest.get('/Event/GetChartsByDayJson',params)
		},
		loadTaskCharts(params){
			return minRequest.get('/Task/GetChartsJson',params)
		},
		loadIndexData(){
			return minRequest.get('/Task/GetIndexData')
		},
		/**
		 * æ–‡ä»¶ä¸Šä¼ 
		 * @param {Object} params - ä¸Šä¼ å‚æ•°
		 * @param {File} params.filePath - æ–‡ä»¶è·¯å¾„
		 * @param {String} params.name - æ–‡ä»¶å‚æ•°å
		 * @param {String} params.fileby - æ–‡ä»¶ç”¨é€”
		 * @param {Number} [params.filetype=1] - æ–‡ä»¶ç±»åž‹ï¼š1å›¾ç‰‡ï¼Œ2excelï¼Œ3templateï¼Œ4æ–‡æ¡£
		 * @returns {Promise}
		 */
		uploadFile(params) {
			const user = Vue.prototype.$store.getters.user
			return new Promise((resolve, reject) => {
				console.log('params', params)

				uni.uploadFile({
					url: globalConfig.baseUrl + '/File/Upload?'+'filetype=4&fileby'+params.fileby,
					filePath: params.filePath,
					name: params.name || 'file',
					header: {
						'WC-Token': user.ApiToken
					},
					formData: {
						fileby: params.fileby || 'default',
						filetype: params.filetype || 1
					},
					success: (res) => {
						if(typeof res.data === 'string') {
							res.data = JSON.parse(res.data)
						}
						if(res.data.code === 0) {
							resolve({
								code: 200,
								msg: 'ä¸Šä¼ æˆåŠŸ',
								data: res.data.data[0].src // è¿”å›žæ–‡ä»¶è·¯å¾„
							})
						} else {
							reject({
								code: res.data.code,
								msg: res.data.msg || 'ä¸Šä¼ å¤±è´¥'
							})
						}
					},
					fail: (err) => {
						reject({
							code: 500,
							msg: err.errMsg || 'ä¸Šä¼ å¤±è´¥'
						})
					}
				})
			})
		}
	}
}
